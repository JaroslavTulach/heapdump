plugins {
    id 'java-library'
    id 'com.github.johnrengelman.shadow' version '5.2.0'
    id 'truffle'
}

sourceSets {
    jmh {
        java.srcDirs = ['src/jmh/java']
        resources.srcDirs = ['src/jmh/resources']
        compileClasspath += sourceSets.main.runtimeClasspath
    }
}

task jmh(type: JavaExec, dependsOn: jmhClasses) {
    main = 'org.openjdk.jmh.Main'
    classpath = sourceSets.jmh.compileClasspath + sourceSets.jmh.runtimeClasspath
    jvmArgs = benchmarkJvmArgs()
}

classes.finalizedBy(jmhClasses)

repositories {
    jcenter()
}

shadowJar {
    mergeServiceFiles()
    from sourceSets.jmh.output
    manifest {
        attributes 'Main-Class': 'org.openjdk.jmh.Main'
    }
}

ext.benchHeap = "$projectDir/../dumps/tumor_cell.hprof"

dependencies {
    implementation project(":oql-engine")
    implementation 'org.netbeans.modules:org-netbeans-modules-profiler-oql:RELEASE113'

    truffleLanguage project(":heap")

    implementation 'org.openjdk.jmh:jmh-core:1.21'
    annotationProcessor 'org.openjdk.jmh:jmh-generator-annprocess:1.21'
    jmhImplementation 'org.openjdk.jmh:jmh-core:1.21'
    jmhAnnotationProcessor 'org.openjdk.jmh:jmh-generator-annprocess:1.21'
}

task bench(type: JavaExec) { task ->
    initBenchmarkTask((JavaExec) task, "")
    task.main("com.oracle.truffle.heap.ScriptRunner")
    task.args = [System.getProperty("heap", "$benchHeap"), System.getProperty("script", "$projectDir/script.js")]
}

task bench01(type: JavaExec) { task ->
    initBenchmarkTask((JavaExec) task, 'benchmark.runner.Bench$Bench_01_Count_objects_via_callback')
}

task bench02(type: JavaExec) { task ->
    initBenchmarkTask((JavaExec) task, 'benchmark.runner.Bench$Bench_02_Count_objects_with_package_via_callback')
}

task bench03(type: JavaExec) { task ->
    initBenchmarkTask((JavaExec) task, 'benchmark.runner.Bench$Bench_03_Count_objects_with_package_via_method_callback')
}

task bench04(type: JavaExec) { task ->
    initBenchmarkTask((JavaExec) task, 'benchmark.runner.Bench$Bench_04_Count_objects_with_package_via_method_string')
}

task bench05(type: JavaExec) { task ->
    initBenchmarkTask((JavaExec) task, 'benchmark.runner.Bench$Bench_05_Complex_where_clause_with_method_callback')
}

@SuppressWarnings("GrMethodMayBeStatic") // it cannot be static - it uses sourceSets
void initBenchmarkTask(JavaExec receiver, String mainClass) {
    receiver.main(mainClass)
    receiver.args(benchHeap)
    receiver.classpath = sourceSets.main.runtimeClasspath
    receiver.jvmArgs = benchmarkJvmArgs()
}

@SuppressWarnings("GrMethodMayBeStatic") // it cannot be static - it references global variables
Iterable<String> benchmarkJvmArgs() {
    List<String> args = new ArrayList<>()
    // Forward benchmark type to the runner.
    args.add('-Dengine='+System.getProperty("engine", "truffle"))
    // If IGV is enabled, instruct Graal to dump compilation graphs.
    if (System.getProperty("igv", "off") == "on") {
        args.add("-Dgraal.Dump=:1")
        args.add("-Dgraal.PrintGraph=Network")
    }
    return args
}